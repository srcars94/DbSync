using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Moq;
using NUnit.Framework;
using Quoting.UI.Infrastructure.Authentication.Cache;

namespace Quoting.UI.Infrastructure.Authentication.Cache.Tests
{
    public interface IMemoryCacheProvider
    {
        object Get(string key);
        void Set(string key, object value, int minutesToLive);
    }

    public interface ISecurityTokenServiceClient
    {
        Task<Dictionary<string, string>> GetToken(string userName, string applicationName);
    }

    [TestFixture]
    public class SecurityTokenCacheTests
    {
        private Mock<IMemoryCacheProvider> _cache;
        private Mock<ISecurityTokenServiceClient> _client;
        private SecurityTokenCache _sut;

        private const string User = "sam.carslake";
        private const string App  = "QuotingUI";
        private const string KeyPrefix = "QuotingUi:Security:Token:";

        [SetUp]
        public void SetUp()
        {
            _cache = new Mock<IMemoryCacheProvider>(MockBehavior.Strict);
            _client = new Mock<ISecurityTokenServiceClient>(MockBehavior.Strict);
            _sut = new SecurityTokenCache(_cache.Object, _client.Object);
        }

        [Test]
        public async Task GetToken_WhenInCache_ReturnsCached_AndSkipsClient()
        {
            var key = KeyPrefix + User;
            var cached = new Dictionary<string, string> { ["access_token"] = "CACHED", ["expires_in"] = "900" };

            _cache.Setup(c => c.Get(key)).Returns(cached);

            var result = await _sut.GetToken(User, App);

            Assert.That(result, Is.SameAs(cached)); // exact instance
            _client.Verify(x => x.GetToken(It.IsAny<string>(), It.IsAny<string>()), Times.Never);
            _cache.Verify(c => c.Get(key), Times.Once);
            _cache.VerifyNoOtherCalls();
        }

        [Test]
        public async Task GetToken_WhenNotInCache_Fetches_SetsCache_For15Minutes_AndReturns()
        {
            var key = KeyPrefix + User;
            var fetched = new Dictionary<string, string> { ["access_token"] = "LIVE", ["expires_in"] = "900" };

            _cache.Setup(c => c.Get(key)).Returns(null!);
            _client.Setup(x => x.GetToken(User, App)).ReturnsAsync(fetched);

            // capture Set call
            _cache.Setup(c => c.Set(
                It.Is<string>(k => k == key),
                It.Is<object>(v => ReferenceEquals(v, fetched)),
                It.Is<int>(mins => mins == 15)));

            var result = await _sut.GetToken(User, App);

            Assert.That(result, Is.SameAs(fetched));
            _cache.Verify(c => c.Get(key), Times.Once);
            _client.Verify(x => x.GetToken(User, App), Times.Once);
            _cache.Verify(c => c.Set(key, fetched, 15), Times.Once);
            _cache.VerifyNoOtherCalls();
            _client.VerifyNoOtherCalls();
        }

        [Test]
        public async Task GetToken_WhenRemoteReturnsNull_ReturnsEmptyDictionary_AndDoesNotCache()
        {
            var key = KeyPrefix + User;

            _cache.Setup(c => c.Get(key)).Returns(null!);
            _client.Setup(x => x.GetToken(User, App)).ReturnsAsync((Dictionary<string, string>)null!);

            var result = await _sut.GetToken(User, App);

            Assert.That(result, Is.Not.Null);
            Assert.That(result, Is.Empty);

            _cache.Verify(c => c.Get(key), Times.Once);
            _client.Verify(x => x.GetToken(User, App), Times.Once);
            _cache.Verify(c => c.Set(It.IsAny<string>(), It.IsAny<object>(), It.IsAny<int>()), Times.Never);
            _cache.VerifyNoOtherCalls();
            _client.VerifyNoOtherCalls();
        }
    }
}