using System;
using System.Collections.Generic;
using NUnit.Framework;

namespace ShallowCloneTests
{
    // ====== SUT ======
    public static class CloneExtensions
    {
        public static T ShallowClone<T>(this T source) where T : class
        {
            if (source == null) throw new ArgumentNullException(nameof(source));

            var type = source.GetType();
            var cloneMethod = type.GetMethod("MemberwiseClone",
                System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

            if (cloneMethod == null)
                throw new InvalidOperationException($"Type {type.FullName} does not support cloning.");

            return (T)cloneMethod.Invoke(source, null)!;
        }
    }

    // ====== Test models ======
    public class Address
    {
        public string City { get; set; } = "";
    }

    public class Person
    {
        public string Name { get; set; } = "";
        public Address Address { get; set; } = new Address();
        public int Age { get; set; }
        public readonly Guid Id = Guid.NewGuid();            // readonly field to ensure it’s copied
        private string _secret = "shh";                      // private field to ensure MemberwiseClone copies it

        public string GetSecret() => _secret;
        public void SetSecret(string s) => _secret = s;
    }

    public sealed class SealedType
    {
        public List<int> Numbers { get; set; } = new List<int> { 1, 2, 3 };
        public int Count => Numbers.Count;
    }

    public class Animal { public string Species { get; set; } = ""; }
    public class Dog : Animal { public string Breed { get; set; } = ""; }

    // ====== Tests ======
    [TestFixture]
    public class ShallowCloneExtensionTests
    {
        [Test]
        public void ShallowClone_Null_Throws()
        {
            Person? source = null;
            Assert.Throws<ArgumentNullException>(() => source!.ShallowClone());
        }

        [Test]
        public void ShallowClone_CopiesTopLevelValues_ButSharesReferences()
        {
            var original = new Person
            {
                Name = "Sam",
                Age = 30,
                Address = new Address { City = "London" }
            };

            var clone = original.ShallowClone();

            // Different top-level references
            Assert.AreNotSame(original, clone);

            // Value-type field copied by value
            Assert.AreEqual(30, clone.Age);
            clone.Age = 31;
            Assert.AreEqual(30, original.Age, "Changing clone value-type should not affect original");

            // Reference-type field shared
            Assert.AreSame(original.Address, clone.Address, "Address should be the same instance (shallow)");
            clone.Address.City = "Manchester";
            Assert.AreEqual("Manchester", original.Address.City, "Changing shared reference affects both");

            // String property (reference type but immutable) value equality
            Assert.AreEqual("Sam", clone.Name);
            clone.Name = "Alex";
            Assert.AreEqual("Sam", original.Name, "Changing string ref to a new string should not affect original");
        }

        [Test]
        public void ShallowClone_CopiesPrivateAndReadonlyFields()
        {
            var original = new Person();
            var originalId = original.Id;
            var originalSecret = original.GetSecret();

            var clone = original.ShallowClone();

            // readonly field copied
            Assert.AreEqual(originalId, clone.Id);

            // private field copied (accessible via method)
            Assert.AreEqual(originalSecret, clone.GetSecret());

            // Mutating clone’s private field doesn’t change original (because top-level object is distinct)
            clone.SetSecret("changed");
            Assert.AreEqual("shh", original.GetSecret());
            Assert.AreEqual("changed", clone.GetSecret());
        }

        [Test]
        public void ShallowClone_WorksForSealedTypes_AndSharesInnerCollections()
        {
            var original = new SealedType();
            var clone = original.ShallowClone();

            Assert.AreNotSame(original, clone);
            Assert.AreEqual(original.Count, clone.Count);

            // Same inner list instance
            Assert.AreSame(original.Numbers, clone.Numbers);

            // Mutate shared list via clone, reflected in original
            clone.Numbers.Add(4);
            Assert.AreEqual(4, original.Count);
        }

        [Test]
        public void ShallowClone_RespectsRuntimeType_WhenVariableIsBaseClass()
        {
            Animal animal = new Dog { Species = "Canine", Breed = "Collie" };
            var clonedAsBase = animal.ShallowClone(); // T inferred as Animal

            // Still a Dog at runtime
            Assert.IsInstanceOf<Dog>(clonedAsBase);
            var dog = (Dog)clonedAsBase;

            Assert.AreEqual("Canine", dog.Species);
            Assert.AreEqual("Collie", dog.Breed);
        }

        [Test]
        public void ShallowClone_ArraysAndLists_AreSharedReferences()
        {
            var original = new
            {
                Numbers = new List<int> { 1, 2, 3 },
                Arr = new[] { "a", "b" }
            };

            var clone = original.ShallowClone();

            // Anonymous type: shallow clone gives another instance with same field refs
            Assert.AreNotSame(original, clone);

            // Lists/arrays share the same reference
            Assert.AreSame(original.Numbers, clone.Numbers);
            Assert.AreSame(original.Arr, clone.Arr);

            // Mutations reflect across both
            clone.Numbers.Add(4);
            Assert.AreEqual(4, original.Numbers.Count);

            clone.Arr[0] = "z";
            Assert.AreEqual("z", original.Arr[0]);
        }
    }
}