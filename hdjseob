using System;
using System.Collections.Generic;
using NUnit.Framework;

namespace ShallowCloneTests
{
    // ====== SUT ======
    public static class CloneExtensions
    {
        public static T ShallowClone<T>(this T source) where T : class
        {
            if (source == null) throw new ArgumentNullException(nameof(source));

            var type = source.GetType();
            var cloneMethod = type.GetMethod("MemberwiseClone",
                System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

            if (cloneMethod == null)
                throw new InvalidOperationException($"Type {type.FullName} does not support cloning.");

            return (T)cloneMethod.Invoke(source, null)!;
        }
    }

    // ====== Test models ======
    public class Address
    {
        public string City { get; set; } = "";
    }

    public class Person
    {
        public string Name { get; set; } = "";
        public Address Address { get; set; } = new Address();
        public int Age { get; set; }
        public readonly Guid Id = Guid.NewGuid();            // readonly field to ensure itâ€™s copied
        private string _secret = "shh";                      // private field to ensure MemberwiseClone copies it

        public string GetSecret() => _secret;
        public void SetSecret(string s) => _secret = s;
    }

    public sealed class SealedType
    {
        public List<int> Numbers { get; set; } = new List<int> { 1, 2, 3 };
        public int Count => Numbers.Count;
    }

    public class Animal { public string Species { get; set; } = ""; }
    public class Dog : Animal { public string Breed { get; set; } = ""; }

    // ====== Tests ======
    [TestFixture]
    public class ShallowCloneExtensionTests
    {
        [Test]
        public void ShallowClone_Null_Throws()
        {
            Person? source = null;
            Assert.Throws<ArgumentNullException>(() => source!.ShallowClone());
        }

        [Test]
        public void ShallowClone_CopiesTopLevelValues_ButSharesReferences()
        {
            var original = new Person
            {
                Name = "Sam",
                Age = 30,
                Address = new Address { City = "London" }
            };

            var clone = original.ShallowClone();

            // Different top-level references
            Assert.AreNotSame(original, clone);

            // Value-type field copied by value
            Assert.AreEqual(30, clone.Age);
            clone.Age = 31;
            Assert.AreEqual(30, original.Age, "Changing clone value-type should not affect original");

            // Reference-type field shared
            Assert.AreSame(original.Address, clone.Address, "Address should be the same instance (shallow)");
            clone.Address.City = "