using System;
using System.Collections.Generic;
using NUnit.Framework;
using Quoting.UI.Shared.Extensions; // where DictionaryExtensions lives

[TestFixture]
public class DictionaryExtensionsTests
{
    // --- Overload: defaultValue (constant) ---

    [Test]
    public void GetValueOrDefaultCustom_ReturnsExistingValue_WhenKeyPresent()
    {
        var dict = new Dictionary<string, int> { ["a"] = 42 };

        var result = dict.GetValueOrDefaultCustom("a", -1);

        Assert.That(result, Is.EqualTo(42));
    }

    [Test]
    public void GetValueOrDefaultCustom_ReturnsDefault_WhenKeyMissing()
    {
        var dict = new Dictionary<string, int> { ["a"] = 42 };

        var result = dict.GetValueOrDefaultCustom("missing", -1);

        Assert.That(result, Is.EqualTo(-1));
    }

    // --- Overload: defaultValueSelector (Func<TValue>) ---

    [Test]
    public void GetValueOrDefaultCustom_SelectorUsed_WhenKeyMissing()
    {
        var dict = new Dictionary<string, string> { ["k"] = "v" };
        var selectorCalls = 0;

        string result = dict.GetValueOrDefaultCustom("missing", () =>
        {
            selectorCalls++;
            return "computed";
        });

        Assert.Multiple(() =>
        {
            Assert.That(result, Is.EqualTo("computed"));
            Assert.That(selectorCalls, Is.EqualTo(1), "Selector should be invoked exactly once.");
        });
    }

    [Test]
    public void GetValueOrDefaultCustom_SelectorNotInvoked_WhenKeyPresent()
    {
        var dict = new Dictionary<string, string> { ["k"] = "v" };
        var selectorCalls = 0;

        string result = dict.GetValueOrDefaultCustom("k", () =>
        {
            selectorCalls++;
            return "should-not-run";
        });

        Assert.Multiple(() =>
        {
            Assert.That(result, Is.EqualTo("v"));
            Assert.That(selectorCalls, Is.EqualTo(0), "Selector must not run if key exists.");
        });
    }

    // --- Null-guarding ---

    [Test]
    public void GetValueOrDefaultCustom_Throws_WhenDictionaryNull_ConstantOverload()
    {
        IDictionary<string, int> dict = null!;

        var ex = Assert.Throws<ArgumentNullException>(() => dict.GetValueOrDefaultCustom("a", 0));
        Assert.That(ex!.ParamName, Is.EqualTo("dictionary"));
    }

    [Test]
    public void GetValueOrDefaultCustom_Throws_WhenDictionaryNull_SelectorOverload()
    {
        IDictionary<string, int> dict = null!;

        var ex = Assert.Throws<ArgumentNullException>(() => dict.GetValueOrDefaultCustom("a", () => 0));
        Assert.That(ex!.ParamName, Is.EqualTo("dictionary"));
    }

    [Test]
    public void GetValueOrDefaultCustom_Throws_WhenKeyNull_ConstantOverload()
    {
        var dict = new Dictionary<string, int>();

        var ex = Assert.Throws<ArgumentNullException>(() => dict.GetValueOrDefaultCustom(null!, 0));
        Assert.That(ex!.ParamName, Is.EqualTo("key"));
    }

    [Test]
    public void GetValueOrDefaultCustom_Throws_WhenKeyNull_SelectorOverload()
    {
        var dict = new Dictionary<string, int>();

        var ex = Assert.Throws<ArgumentNullException>(() => dict.GetValueOrDefaultCustom(null!, () => 0));
        Assert.That(ex!.ParamName, Is.EqualTo("key"));
    }

    // --- Reference type value (sanity) ---

    private sealed class Foo { public int Id { get; init; } }

    [Test]
    public void GetValueOrDefaultCustom_ReferenceType_DefaultReturnedWhenMissing()
    {
        var dict = new Dictionary<int, Foo> { [1] = new Foo { Id = 1 } };

        var result = dict.GetValueOrDefaultCustom(2, new Foo { Id = -1 });

        Assert.That(result.Id, Is.EqualTo(-1));
    }
}